--- a/str.c	2009-10-27 21:59:21.000000000 -0200
+++ b/str.c	2022-09-05 09:03:15.000000000 -0300
@@ -39,7 +39,7 @@
 
 #include <sys/types.h>
 #include <stdarg.h>
-#include <vis.h>
+#include <bsd/vis.h>
 
 #include "csh.h"
 #include "extern.h"
--- a/proc.c	2009-10-27 21:59:21.000000000 -0200
+++ b/proc.c	2022-09-07 23:42:49.696792154 -0300
@@ -75,13 +75,12 @@
     int pid;
     extern int insource;
     int save_errno = errno;
-    union wait w;
-    int     jobflags;
+    int     jobflags, w;
     struct rusage ru;
 
 loop:
     errno = 0;			/* reset, just in case */
-    pid = wait3(&w.w_status,
+    pid = wait4((pid_t)-1, &w,
        (setintr && (intty || insource) ? WNOHANG | WUNTRACED : WNOHANG), &ru);
 
     if (pid <= 0) {
@@ -103,7 +102,7 @@
     pp->p_flags &= ~(PRUNNING | PSTOPPED | PREPORTED);
     if (WIFSTOPPED(w)) {
 	pp->p_flags |= PSTOPPED;
-	pp->p_reason = w.w_stopsig;
+	pp->p_reason = w;
     }
     else {
 	if (pp->p_flags & (PTIME | PPTIME) || adrof(STRtime))
@@ -111,16 +110,16 @@
 
 	pp->p_rusage = ru;
 	if (WIFSIGNALED(w)) {
-	    if (w.w_termsig == SIGINT)
+	    if (w == SIGINT)
 		pp->p_flags |= PINTERRUPTED;
 	    else
 		pp->p_flags |= PSIGNALED;
-	    if (w.w_coredump)
+	    if (w)
 		pp->p_flags |= PDUMPED;
-	    pp->p_reason = w.w_termsig;
+	    pp->p_reason = w;
 	}
 	else {
-	    pp->p_reason = w.w_retcode;
+	    pp->p_reason = w;
 	    if (pp->p_reason != 0)
 		pp->p_flags |= PAEXITED;
 	    else
--- a/func.c	2009-10-27 21:59:21.000000000 -0200
+++ b/func.c	2022-09-05 19:05:26.399126249 -0300
@@ -1063,7 +1063,7 @@
     (void) umask(i);
 }
 
-typedef quad_t RLIM_TYPE;
+typedef int64_t RLIM_TYPE;
 
 static struct limits {
     int     limconst;
--- a/const.h	1969-12-31 21:00:00.000000000 -0300
+++ b/const.h	2022-09-05 09:03:15.000000000 -0300
@@ -0,0 +1,111 @@
+/* Do not edit this file, make creates it. */
+extern Char STR0[];
+extern Char STR1[];
+extern Char STRHOME[];
+extern Char STRLANG[];
+extern Char STRLC_CTYPE[];
+extern Char STRLOGNAME[];
+extern Char STRLbrace[];
+extern Char STRLparen[];
+extern Char STRLparensp[];
+extern Char STRNULL[];
+extern Char STRPATH[];
+extern Char STRPWD[];
+extern Char STRQNULL[];
+extern Char STRRbrace[];
+extern Char STRRparen[];
+extern Char STRTERM[];
+extern Char STRUSER[];
+extern Char STRalias[];
+extern Char STRand2[];
+extern Char STRand[];
+extern Char STRaout[];
+extern Char STRargv[];
+extern Char STRbang[];
+extern Char STRcaret[];
+extern Char STRcdpath[];
+extern Char STRcent2[];
+extern Char STRcenthash[];
+extern Char STRcentminus[];
+extern Char STRcentplus[];
+extern Char STRchase_symlinks[];
+extern Char STRchild[];
+extern Char STRcolon[];
+extern Char STRcwd[];
+extern Char STRdefault[];
+extern Char STRdot[];
+extern Char STRdotdotsl[];
+extern Char STRdotsl[];
+extern Char STRecho[];
+extern Char STRequal[];
+extern Char STRfakecom1[];
+extern Char STRfakecom[];
+extern Char STRfignore[];
+extern Char STRfilec[];
+extern Char STRhistchars[];
+extern Char STRhistfile[];
+extern Char STRhistory[];
+extern Char STRhome[];
+extern Char STRignore_symlinks[];
+extern Char STRignoreeof[];
+extern Char STRjobs[];
+extern Char STRlistjobs[];
+extern Char STRlogout[];
+extern Char STRlong[];
+extern Char STRmail[];
+extern Char STRmh[];
+extern Char STRminus[];
+extern Char STRml[];
+extern Char STRmn[];
+extern Char STRmquestion[];
+extern Char STRmZ[];
+extern Char STRnice[];
+extern Char STRnoambiguous[];
+extern Char STRnobeep[];
+extern Char STRnoclobber[];
+extern Char STRnoglob[];
+extern Char STRnohup[];
+extern Char STRnonomatch[];
+extern Char STRnormal[];
+extern Char STRnotify[];
+extern Char STRor2[];
+extern Char STRor[];
+extern Char STRpath[];
+extern Char STRprintexitvalue[];
+extern Char STRprompt2[];
+extern Char STRprompt[];
+extern Char STRpushdsilent[];
+extern Char STRret[];
+extern Char STRsavehist[];
+extern Char STRsemisp[];
+extern Char STRshell[];
+extern Char STRslash[];
+extern Char STRsldotcshrc[];
+extern Char STRsldotlogin[];
+extern Char STRsldthist[];
+extern Char STRsldtlogout[];
+extern Char STRsource[];
+extern Char STRsp3dots[];
+extern Char STRspLarrow2sp[];
+extern Char STRspLarrowsp[];
+extern Char STRspRarrow2[];
+extern Char STRspRarrow[];
+extern Char STRspRparen[];
+extern Char STRspace[];
+extern Char STRspand2sp[];
+extern Char STRspor2sp[];
+extern Char STRsporsp[];
+extern Char STRstar[];
+extern Char STRstatus[];
+extern Char STRsymcent[];
+extern Char STRsymhash[];
+extern Char STRterm[];
+extern Char STRthen[];
+extern Char STRtilde[];
+extern Char STRtildothist[];
+extern Char STRtime[];
+extern Char STRtmpsh[];
+extern Char STRunalias[];
+extern Char STRuser[];
+extern Char STRverbose[];
+extern Char STRwordchars[];
--- a/error.h	1969-12-31 21:00:00.000000000 -0300
+++ b/error.h	2022-09-05 09:03:15.000000000 -0300
@@ -0,0 +1,119 @@
+/* Do not edit this file, make creates it. */
+#ifndef _h_sh_err
+#define _h_sh_err
+#define ERR_FLAGS	0xf0000000
+#define ERR_NAME	0x10000000
+#define ERR_SILENT	0x20000000
+#define ERR_OLD		0x40000000
+#define ERR_SYNTAX	0
+#define ERR_NOTALLOWED	1
+#define ERR_WTOOLONG	2
+#define ERR_LTOOLONG	3
+#define ERR_DOLZERO	4
+#define ERR_DOLQUEST	5
+#define ERR_INCBR	6
+#define ERR_EXPORD	7
+#define ERR_BADMOD	8
+#define ERR_SUBSCRIPT	9
+#define ERR_BADNUM	10
+#define ERR_NOMORE	11
+#define ERR_FILENAME	12
+#define ERR_GLOB	13
+#define ERR_COMMAND	14
+#define ERR_TOOFEW	15
+#define ERR_TOOMANY	16
+#define ERR_DANGER	17
+#define ERR_EMPTYIF	18
+#define ERR_IMPRTHEN	19
+#define ERR_NOPAREN	20
+#define ERR_NOTFOUND	21
+#define ERR_MASK	22
+#define ERR_LIMIT	23
+#define ERR_TOOLARGE	24
+#define ERR_SCALEF	25
+#define ERR_UNDVAR	26
+#define ERR_DEEP	27
+#define ERR_BADSIG	28
+#define ERR_UNKSIG	29
+#define ERR_VARBEGIN	30
+#define ERR_VARTOOLONG	31
+#define ERR_VARALNUM	32
+#define ERR_JOBCONTROL	33
+#define ERR_EXPRESSION	34
+#define ERR_NOHOMEDIR	35
+#define ERR_CANTCHANGE	36
+#define ERR_NULLCOM	37
+#define ERR_ASSIGN	38
+#define ERR_UNKNOWNOP	39
+#define ERR_AMBIG	40
+#define ERR_EXISTS	41
+#define ERR_INTR	42
+#define ERR_RANGE	43
+#define ERR_OVERFLOW	44
+#define ERR_VARMOD	45
+#define ERR_NOSUCHJOB	46
+#define ERR_TERMINAL	47
+#define ERR_NOTWHILE	48
+#define ERR_NOPROC	49
+#define ERR_NOMATCH	50
+#define ERR_MISSING	51
+#define ERR_UNMATCHED	52
+#define ERR_NOMEM	53
+#define ERR_PIPE	54
+#define ERR_SYSTEM	55
+#define ERR_STRING	56
+#define ERR_JOBS	57
+#define ERR_JOBARGS	58
+#define ERR_JOBCUR	59
+#define ERR_JOBPREV	60
+#define ERR_JOBPAT	61
+#define ERR_NESTING	62
+#define ERR_JOBCTRLSUB	63
+#define ERR_BADPLPS	64
+#define ERR_STOPPED	65
+#define ERR_NODIR	66
+#define ERR_EMPTY	67
+#define ERR_BADDIR	68
+#define ERR_DIRUS	69
+#define ERR_HFLAG	70
+#define ERR_NOTLOGIN	71
+#define ERR_DIV0	72
+#define ERR_MOD0	73
+#define ERR_BADSCALE	74
+#define ERR_SUSPLOG	75
+#define ERR_UNKUSER	76
+#define ERR_NOHOME	77
+#define ERR_HISTUS	78
+#define ERR_SPDOLLT	79
+#define ERR_NEWLINE	80
+#define ERR_SPSTAR	81
+#define ERR_DIGIT	82
+#define ERR_VARILL	83
+#define ERR_NLINDEX	84
+#define ERR_EXPOVFL	85
+#define ERR_VARSYN	86
+#define ERR_BADBANG	87
+#define ERR_NOSUBST	88
+#define ERR_BADSUBST	89
+#define ERR_LHS		90
+#define ERR_RHSLONG	91
+#define ERR_BADBANGMOD	92
+#define ERR_MODFAIL	93
+#define ERR_SUBOVFL	94
+#define ERR_BADBANGARG	95
+#define ERR_NOSEARCH	96
+#define ERR_NOEVENT	97
+#define ERR_TOOMANYRP	98
+#define ERR_TOOMANYLP	99
+#define ERR_BADPLP	100
+#define ERR_MISRED	101
+#define ERR_OUTRED	102
+#define ERR_REDPAR	103
+#define ERR_INRED	104
+#define ERR_ALIASLOOP	105
+#define ERR_HISTLOOP	106
+#define ERR_ARCH	107
+#define ERR_FILEINQ	108
+#define ERR_SELOVFL	109
+#define ERR_INVALID	110
+#endif /* _h_sh_err */
--- a/file.c	2009-10-27 21:59:21.000000000 -0200
+++ b/file.c	2022-12-26 17:02:23.441955284 -0300
@@ -30,6 +30,10 @@
  * SUCH DAMAGE.
  */
 
+#ifdef BIONIC
+#define MAXNAMLEN 1024
+#endif
+
 #ifdef FILEC
 
 #include <sys/param.h>
@@ -82,7 +86,7 @@
 static void	 beep(void);
 static void	 print_recognized_stuff(Char *);
 static void	 extract_dir_and_name(Char *, Char *, Char *);
-static Char	*getentry(DIR *, int);
+static Char	*getentry(DIR *);
 static void	 free_items(Char **, int);
 static int	 tsearch(Char *, COMMAND, int);
 static int	 recognize(Char *, Char *, int, int);
@@ -373,16 +377,10 @@
 }
 
 static Char *
-getentry(DIR *dir_fd, int looking_for_lognames)
+getentry(DIR *dir_fd)
 {
-    struct passwd *pw;
     struct dirent *dirp;
 
-    if (looking_for_lognames) {
-	if ((pw = getpwent()) == NULL)
-	    return (NULL);
-	return (str2short(pw->pw_name));
-    }
     if ((dirp = readdir(dir_fd)) != NULL)
 	return (str2short(dirp->d_name));
     return (NULL);
@@ -416,36 +414,27 @@
 {
     DIR *dir_fd;
     int numitems = 0, ignoring = TRUE, nignored = 0;
-    int name_length, looking_for_lognames;
+    int name_length;
     Char    tilded_dir[MAXPATHLEN], dir[MAXPATHLEN];
     Char    name[MAXNAMLEN + 1], extended_name[MAXNAMLEN + 1];
     Char   *entry;
     Char   **items = NULL;
     size_t  maxitems = 0;
 
-    looking_for_lognames = (*word == '~') && (Strchr(word, '/') == NULL);
-    if (looking_for_lognames) {
-	(void) setpwent();
-	copyn(name, &word[1], MAXNAMLEN);	/* name sans ~ */
-	dir_fd = NULL;
-    }
-    else {
-	extract_dir_and_name(word, dir, name);
-	if (tilde(tilded_dir, dir) == 0)
-	    return (0);
-	dir_fd = opendir(*tilded_dir ? short2str(tilded_dir) : ".");
-	if (dir_fd == NULL)
-	    return (0);
-    }
+    extract_dir_and_name(word, dir, name);
+    if (tilde(tilded_dir, dir) == 0)
+	return (0);
+    dir_fd = opendir(*tilded_dir ? short2str(tilded_dir) : ".");
+    if (dir_fd == NULL)
+	return (0);
 
 again:				/* search for matches */
     name_length = Strlen(name);
-    for (numitems = 0; (entry = getentry(dir_fd, looking_for_lognames)) != NULL;) {
+    for (numitems = 0; (entry = getentry(dir_fd)) != NULL;) {
 	if (!is_prefix(name, entry))
 	    continue;
 	/* Don't match . files on null prefix match */
-	if (name_length == 0 && entry[0] == '.' &&
-	    !looking_for_lognames)
+	if (name_length == 0 && entry[0] == '.')
 	    continue;
 	if (command == LIST) {
 	    if (numitems >= maxitems) {
@@ -472,25 +461,16 @@
     if (ignoring && numitems == 0 && nignored > 0) {
 	ignoring = FALSE;
 	nignored = 0;
-	if (looking_for_lognames)
-	    (void) setpwent();
-	else
-	    rewinddir(dir_fd);
+	rewinddir(dir_fd);
 	goto again;
     }
 
-    if (looking_for_lognames)
-	(void) endpwent();
-    else
-	(void) closedir(dir_fd);
+    (void) closedir(dir_fd);
     if (numitems == 0)
 	return (0);
     if (command == RECOGNIZE) {
-	if (looking_for_lognames)
-	    copyn(word, STRtilde, 1);
-	else
-	    /* put back dir part */
-	    copyn(word, dir, max_word_length);
+	/* put back dir part */
+	copyn(word, dir, max_word_length);
 	/* add extended name */
 	catn(word, extended_name, max_word_length);
 	return (numitems);
@@ -498,8 +478,7 @@
     else {			/* LIST */
 	qsort((ptr_t) items, numitems, sizeof(*items),
 		(int (*)(const void *, const void *)) sortscmp);
-	print_by_column(looking_for_lognames ? NULL : tilded_dir,
-			items, numitems);
+	print_by_column(tilded_dir, items, numitems);
 	if (items != NULL)
 	    FREE_ITEMS(items);
     }
--- a/csh.c	2009-10-27 21:59:21.000000000 -0200
+++ b/csh.c	2022-12-27 05:48:42.222558728 -0300
@@ -37,12 +37,14 @@
 #include <fcntl.h>
 #include <errno.h>
 #include <pwd.h>
+#include <bsd/stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <locale.h>
 #include <unistd.h>
-#include <vis.h>
+#include <bsd/vis.h>
 #include <stdarg.h>
+#include <time.h>
 
 #include "csh.h"
 #include "proc.h"
--- a/Makefile	2010-01-04 15:50:36.000000000 -0200
+++ b/Makefile	2022-12-27 09:36:26.687720049 -0300
@@ -9,17 +9,21 @@
 DFLAGS=-DBUILTIN -DFILEC -DNLS -DSHORT_STRINGS
 #CFLAGS+=-g
 #CFLAGS+=-Wall
-CFLAGS+=-I${.CURDIR} -I. ${DFLAGS}
+CFLAGS+=-z muldefs -I${PREFIX}/include -L${PREFIX}/lib -L/system/lib ${DFLAGS}
 SRCS=	alloc.c char.c const.c csh.c dir.c dol.c error.c exec.c exp.c file.c \
 	func.c glob.c hist.c init.c lex.c misc.c parse.c proc.c \
 	sem.c set.c str.c time.c
 
-CLEANFILES+=error.h const.h
+CLEANFILES=*.o csh
 
-.if (${MACHINE_ARCH} == "vax")
-alloc.o:
-	${CC} ${CFLAGS} ${CPPFLAGS} -O0 -c $<
-.endif
+all:
+	${CC} -o ${PROG} ${CFLAGS} -DBIONIC ${SRCS} -lbsd -landroid-glob -lc
+
+clean:
+	rm -f ${CLEANFILES}
+
+install:
+	install -p csh ${PREFIX}/bin/
 
 const.h: error.h
 
@@ -28,16 +32,14 @@
 	@echo '/* Do not edit this file, make creates it. */' > $@
 	@echo '#ifndef _h_sh_err' >> $@
 	@echo '#define _h_sh_err' >> $@
-	egrep 'ERR_' ${.CURDIR}/$*.c | egrep '^#define' >> $@
+	egrep 'ERR_' *.c | egrep '^#define' >> $@
 	@echo '#endif /* _h_sh_err */' >> $@
 
 const.h: const.c
 	@rm -f $@
 	@echo '/* Do not edit this file, make creates it. */' > $@
-	${CC} -E ${CFLAGS} ${.CURDIR}/$*.c | egrep 'Char STR' | \
+	${CC} -E ${CFLAGS} *.c | egrep 'Char STR' | \
 	    sed -e 's/Char \([a-zA-Z0-9_]*\)\(.*\)/extern Char \1[];/' | \
 	    sort >> $@
 
 .depend alloc.o: const.h error.h 
-
-.include <bsd.prog.mk>
--- a/LICENSE	1969-12-31 21:00:00.000000000 -0300
+++ b/LICENSE	2022-12-08 13:18:25.000000000 -0300
@@ -0,0 +1,25 @@
+Copyright (c) 1980, 1991, 1993 The Regents of the University of California.  All rights reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the University nor the names of its contributors
+   may be used to endorse or promote products derived from this software
+   without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGE.
